"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = require("metaverse-rpc/lib/common/core/EventDispatcher");
/**
 * MessageBusClient provides an easy way to send and reveive peer to peer
 * messages thru the communications interface of Decentraland.
 *
 * The usage is simple, it implements a pub-sub pattern that shares messages
 * using the connection that already exists between peers.
 *
 * @example inside your ScriptableScene
 * ```ts
 *   let messageBusClient = await MessageBusClient.acquireEstateChannel(this)
 *   messageBusClient.on('a message name', (message) => {...})
 *   messageBusClient.emit('a message name', message)
 * ```
 */
class MessageBusClient extends EventDispatcher_1.EventDispatcher {
    constructor(api, id, busClientId) {
        super();
        this.api = api;
        this.id = id;
        this.busClientId = busClientId;
        api[`on${this.id}`]((message) => {
            if (this.busClientId !== message.sender) {
                super.emit(message.event, ...message.args);
            }
        });
    }
    static async acquireEstateChannel(system) {
        const busId = Math.random().toString(36);
        const { MessageBus } = await system.loadAPIs(['MessageBus']);
        const bus = await MessageBus.getEstateChannel();
        return new MessageBusClient(MessageBus, bus.id, busId);
    }
    emit(event, ...args) {
        this.api[this.id]({
            event,
            args,
            sender: this.busClientId
        });
        super.emit(event, ...args);
    }
}
exports.MessageBusClient = MessageBusClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVzc2FnZUJ1cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9NZXNzYWdlQnVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbUZBQStFO0FBUy9FOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxzQkFBdUMsU0FBUSxpQ0FBa0I7SUFDL0QsWUFBOEIsR0FBUSxFQUFZLEVBQVUsRUFBWSxXQUFtQjtRQUN6RixLQUFLLEVBQUUsQ0FBQTtRQURxQixRQUFHLEdBQUgsR0FBRyxDQUFLO1FBQVksT0FBRSxHQUFGLEVBQUUsQ0FBUTtRQUFZLGdCQUFXLEdBQVgsV0FBVyxDQUFRO1FBRXpGLEdBQUcsQ0FBQyxLQUFLLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBaUIsRUFBRSxFQUFFO1lBQ3hDLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxPQUFPLENBQUMsTUFBTSxFQUFFO2dCQUN2QyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUE7YUFDM0M7UUFDSCxDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLE1BQXVCO1FBQ3ZELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUE7UUFDeEMsTUFBTSxFQUFFLFVBQVUsRUFBRSxHQUFHLE1BQU0sTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUE7UUFFNUQsTUFBTSxHQUFHLEdBQUcsTUFBTSxVQUFVLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQTtRQUUvQyxPQUFPLElBQUksZ0JBQWdCLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUE7SUFDeEQsQ0FBQztJQUVELElBQUksQ0FBQyxLQUFhLEVBQUUsR0FBRyxJQUFXO1FBQ2hDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2hCLEtBQUs7WUFDTCxJQUFJO1lBQ0osTUFBTSxFQUFFLElBQUksQ0FBQyxXQUFXO1NBQ2IsQ0FBQyxDQUFBO1FBQ2QsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQTtJQUM1QixDQUFDO0NBQ0Y7QUEzQkQsNENBMkJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnbWV0YXZlcnNlLXJwYy9saWIvY29tbW9uL2NvcmUvRXZlbnREaXNwYXRjaGVyJ1xuaW1wb3J0IHsgU2NyaXB0YWJsZVNjZW5lIH0gZnJvbSAnLidcblxuZXhwb3J0IGludGVyZmFjZSBJTWVzc2FnZSB7XG4gIGV2ZW50OiBzdHJpbmdcbiAgYXJnczogYW55W11cbiAgc2VuZGVyOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBNZXNzYWdlQnVzQ2xpZW50IHByb3ZpZGVzIGFuIGVhc3kgd2F5IHRvIHNlbmQgYW5kIHJldmVpdmUgcGVlciB0byBwZWVyXG4gKiBtZXNzYWdlcyB0aHJ1IHRoZSBjb21tdW5pY2F0aW9ucyBpbnRlcmZhY2Ugb2YgRGVjZW50cmFsYW5kLlxuICpcbiAqIFRoZSB1c2FnZSBpcyBzaW1wbGUsIGl0IGltcGxlbWVudHMgYSBwdWItc3ViIHBhdHRlcm4gdGhhdCBzaGFyZXMgbWVzc2FnZXNcbiAqIHVzaW5nIHRoZSBjb25uZWN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMgYmV0d2VlbiBwZWVycy5cbiAqXG4gKiBAZXhhbXBsZSBpbnNpZGUgeW91ciBTY3JpcHRhYmxlU2NlbmVcbiAqIGBgYHRzXG4gKiAgIGxldCBtZXNzYWdlQnVzQ2xpZW50ID0gYXdhaXQgTWVzc2FnZUJ1c0NsaWVudC5hY3F1aXJlRXN0YXRlQ2hhbm5lbCh0aGlzKVxuICogICBtZXNzYWdlQnVzQ2xpZW50Lm9uKCdhIG1lc3NhZ2UgbmFtZScsIChtZXNzYWdlKSA9PiB7Li4ufSlcbiAqICAgbWVzc2FnZUJ1c0NsaWVudC5lbWl0KCdhIG1lc3NhZ2UgbmFtZScsIG1lc3NhZ2UpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE1lc3NhZ2VCdXNDbGllbnQ8VCA9IGFueT4gZXh0ZW5kcyBFdmVudERpc3BhdGNoZXI8VD4ge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBhcGk6IGFueSwgcHJvdGVjdGVkIGlkOiBzdHJpbmcsIHByb3RlY3RlZCBidXNDbGllbnRJZDogc3RyaW5nKSB7XG4gICAgc3VwZXIoKVxuICAgIGFwaVtgb24ke3RoaXMuaWR9YF0oKG1lc3NhZ2U6IElNZXNzYWdlKSA9PiB7XG4gICAgICBpZiAodGhpcy5idXNDbGllbnRJZCAhPT0gbWVzc2FnZS5zZW5kZXIpIHtcbiAgICAgICAgc3VwZXIuZW1pdChtZXNzYWdlLmV2ZW50LCAuLi5tZXNzYWdlLmFyZ3MpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBhY3F1aXJlRXN0YXRlQ2hhbm5lbChzeXN0ZW06IFNjcmlwdGFibGVTY2VuZSkge1xuICAgIGNvbnN0IGJ1c0lkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNilcbiAgICBjb25zdCB7IE1lc3NhZ2VCdXMgfSA9IGF3YWl0IHN5c3RlbS5sb2FkQVBJcyhbJ01lc3NhZ2VCdXMnXSlcblxuICAgIGNvbnN0IGJ1cyA9IGF3YWl0IE1lc3NhZ2VCdXMuZ2V0RXN0YXRlQ2hhbm5lbCgpXG5cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VCdXNDbGllbnQoTWVzc2FnZUJ1cywgYnVzLmlkLCBidXNJZClcbiAgfVxuXG4gIGVtaXQoZXZlbnQ6IHN0cmluZywgLi4uYXJnczogYW55W10pIHtcbiAgICB0aGlzLmFwaVt0aGlzLmlkXSh7XG4gICAgICBldmVudCxcbiAgICAgIGFyZ3MsXG4gICAgICBzZW5kZXI6IHRoaXMuYnVzQ2xpZW50SWRcbiAgICB9IGFzIElNZXNzYWdlKVxuICAgIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpXG4gIH1cbn1cbiJdfQ==